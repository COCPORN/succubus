{"name":"Succubus","tagline":"A \"service bus\" implementation created on top of ZeroMQ","body":"Succubus\r\n========\r\n\r\nA light .NET distributed application framework created on top of ZeroMQ.\r\n\r\nAbout\r\n-----\r\n\r\nSuccubus is a simple (at this point) implementation of convenience functions for .NET on top of ZeroMQ, presenting an interface similar to that of MassTransit.\r\n\r\nBecause it uses ZeroMQ, all brokers live in the Succubus process space, and you do not install anything besides the dependencies in the library.\r\n\r\nSuccubus is currently in a pre-release but usable state. The repository will go public once it reaches a 0.2-release.\r\n\r\nFeatures\r\n--------\r\n\r\nThese are the current and planned features of Succubus:\r\n\r\n- Event publishing and consumption\r\n- Synchronous calls with request/response\r\n- Orchestration of synchronous messages\r\n- Timeouts of synchronous messages\r\n- Planned for 0.3:\r\n\t- Addressable commands\r\n\t- Work-item fan out\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nGet lastest version of Succubus from GitHub or NuGet.\r\n\r\nRelevant packages:\r\n\r\n- Succubus\r\n- Succubus.Backend.ZeroMQ\r\n- Succubus.Hosting (to be renamed to Succubus.Hosting.ZeroMQ prior to 1.0 release)\r\n\r\nInstantiation\r\n-------------\r\n\r\nTo instantiate a handle to the bus, create an instance of `Succubus.Core.Bus`:\r\n```C#\r\nIBus bus = new Succubus.Core.Bus();\r\n```\r\n\r\nEach handle will have a separate channel to the message host. Each handle will also have separate event handlers, and synchronous message responses need to be handled on the same bus as the request.\r\n\r\nSingleton instantiation\r\n-----------------------\r\n\r\nSuccubus allows you to get a singleton instance in addition to newing up objects. Note that the singleton object will always (obviously) point to the same instance, while all newed objects will be different. These can co-exist and will use separate message channels:\r\n\r\n```C#\r\nBus.Instance.Initialize(config => {\r\n    // Manipulate config-handle\r\n});\r\n```\r\n\r\nInitialization\r\n--------------\r\n\r\nBefore using the bus, it needs to be initialized:\r\n\r\n```C#\r\nBus.Instance.Initialize();\r\n```\r\n\r\nThe `Initialize`-call to the bus alternatively returns a configuration handle.\r\n\r\n```C#\r\nbus.Initialize(succubus =>\r\n{\r\n    succubus.WithZeroMQ();\r\n});\r\n```\r\n\r\nWhen using the parameterless Initialize call, the bus will be initialized with default values. To actually start the message host, the Succubus.Hosting-assembly must be referenced.\r\n\r\nBackends\r\n--------\r\n\r\nFor Succubus to work, it needs a _backend_. The Loopback backend is always present, so you can initialize like this:\r\n\r\n```C#\r\nbus.Initialize(succubus => succubus.WithLoopback());\r\n```\r\n\r\nOther backends include ZeroMQ:\r\n\r\n```C#\r\nbus.Initialize(succubus => succubus.WithZeroMQ(zmq => {\r\n    zmq.PublishAddress = \"...\";\r\n    zmq.SubscribeAddress = \"...\";\r\n}))\r\n```\r\n\r\nIf you are also wanting to run a ZeroMQ host in the process, you can:\r\n\r\n```C#\r\nbus.Initialize(succubus => succubus.WithZeroMQ(zmq => {\r\n    zmq.StartMessageHost();\r\n}))\r\n```\r\n\r\nThese examples rely on using `Succubus.Backend.ZeroMQ` and `Succubus.Hosting.ZeroMQ` respectively.\r\n\r\nEvents\r\n------\r\n\r\nSuccubus supports publishing and consuming events. Events are agnostic to where they are posted from and who consumes them. A single event can have multiple consumers.\r\n\r\n### Publishing events\r\n\r\nPublish events by calling the `Publish`-method:\r\n\r\n```C#\r\nbus.Publish(new BasicEvent { Message = \"Hi, there! \"});\r\n```\r\n\r\n`BasicEvent` is a user defined POCO-class:\r\n\r\n```C#\r\npublic class BasicEvent\r\n{\r\n    public string Message { get; set; }\r\n}\r\n```\r\n\r\n### Consuming events\r\n\r\nIf you are interested in handling an event, use the `On`-method:\r\n\r\n```C#\r\nbus.On<BasicEvent>(e => {\r\n\tConsole.WriteLine(\"Got event: {0}\", e.Message)\r\n});\r\n```\r\n\r\nSynchronous processing\r\n----------------------\r\n\r\nSuccubus supports two types of synchronous calling; static and transient routes. A transient route is setup as the call is made, and is removed after a call has been processed, while a static route is permanent in the bus.\r\n\r\nWhen using synchronous processing, the _client_ side of the interaction needs to use a variation of the `Call`-method and the _server_ side then replies using the `ReplyTo`-method.\r\n\r\n### Replying to messages\r\n\r\nWhen a message is presented from the bus after being sent with the `Call`-method, it can be handled with the `ReplyTo`-method:\r\n\r\n```C#\r\nbus.ReplyTo<BasicRequest, BasicResponse>(request => {\r\n\treturn new BasicResponse { Message = request.Message + \" echoed from server\" };\r\n});\r\n```\r\n\r\nNote that `BasicRequest` and `BasicResponse` are user defined POCO-classes; Succubus will handle any routing information behind the scenes.\r\n\r\n### Transient routes\r\n\r\nTransient routes are simple request/response-pairs.\r\n\r\n```C#\r\nbus.Call<Request, Response>(new Request { Message = \"Hi from client\"},\r\n\tresponse => {\r\n\t\tConsole.WriteLine(\"Got response from server: {0}\", response.Message);\r\n\t});\r\n```\r\n\r\nA transient call with request/response-parameters will register a route and wrap the request/response objects in a `SynchronousMessageFrame` which decorates the messages with `CorrelationId`s. If multiple responses are made to the same synchronous call, only the first will be handled in the defined response handler, all other messages will be silently discarded.\r\n\r\n### Static routes\r\n\r\nStatic routes allow for reuse of handler structures and more advanced orchestration.\r\n\r\n```C#\r\nbus.OnReply<BasicRequest, BasicResponse>((request, response) => \r\n    Console.WriteLine(\"OnReply<TReq, TRes>: Got a response handled on static handler: {0} => {1}\", \r\n    request.Message, \r\n    response.Message));\r\nbus.Call<BasicRequest>(new BasicRequest { Message = \"Hello from client\"} );\r\n```\r\n\r\nSuccubus will store the request until the response arrives, so both can be handled in the same context.\r\n\r\n### Response filtering\r\n\r\nYou can setup response filtering through inheritance. Example:\r\n\r\n```C#\r\npublic class BaseResponse \r\n{\r\n    public string Message { get; set; }\r\n}\r\n\r\npublic class SuccessResponse : BaseResponse\r\n{\r\n    public SuccessResponse() \r\n    {\r\n        Message = \"All went well\";\r\n    }\r\n}\r\n\r\npublic class FailureResponse : BaseResponse\r\n{\r\n    public FailureResponse() \r\n    {\r\n        Message = \"What a catastrophic failure.\";\r\n    }\r\n}\r\n\r\npublic class Request \r\n{\r\n    public string Message { get; set; }\r\n}\r\n```\r\n\r\nWith these classes we can setup the handling of the static routes.\r\n\r\n```C#\r\nbus.ReplyTo<Request,BaseResponse>((req) =>\r\n{\r\n    if (failure)\r\n    {\r\n        return new FailureResponse();\r\n    }\r\n    else \r\n    {\r\n        return new SuccessResponse();\r\n    }\r\n});\r\n\r\n```\r\n\r\nThen, on the client side, we can handle both responses separately:\r\n\r\n```C#\r\nbus.OnReply<Request, FailureResponse>((req, res) =>\r\n{\r\n    Console.WriteLine(\"Shoot, something went wrong processing the request: {0}\", res.Message);\r\n});\r\n\r\nbus.OnReply<Request, SuccessResponse>((req, res) =>\r\n{\r\n    Console.WriteLine(\"Everything processed without a hitch: {0}\", res.Message);\r\n});\r\n\r\n```\r\n\r\nIt is also possible to do:\r\n\r\n```C#\r\nbus.OnReply<Request, BaseResponse>((req, res) =>\r\n{\r\n    if (res is FailureResponse) {\r\n        // ...\r\n    } else if (res is SuccessResponse) {\r\n        // ...\r\n    }\r\n});\r\n```\r\n\r\nThis means you can route incoming responses based on interface-definitions and abstract classes, in addition to obviously concrete classes.\r\n\r\n### Timeouts\r\n\r\nSynchronized processing supports timeout handlers on a per-`Call` basis. Example:\r\n\r\n```C#\r\nbus.Call(new BasicRequest { Message = \"Hello! \"}, (req) => {\r\n\tConsole.WriteLine(\"BasicRequest timed out for: {0}\", req.Message)\r\n}, 2500); // Timeout in milliseconds\r\n```\r\n\r\nIf no parameters are provided, the call will time out silently after \r\none minute. To make a response handler never time out, manually provide\r\nthe value of 0.\r\n\r\n### Orchestration\r\n\r\nSynchronous processing in Succubus opens up for complex orchestration of up to 7 responses. Example:\r\n\r\n```C#\r\nbus.OnReply<UpdateRequest, \r\n            ImageProcessed, \r\n            FriendNotified>((ur, ip, fn) =>\r\n{\r\n\tConsole.WriteLine(\"New profile image has been processed with response: {0}\", ip.Status);\r\n\tConsole.WriteLine(\"Friends have been notified with response: {0}\", fn.Status);\r\n});\r\n\t\r\n```\r\n\r\n\r\nWorkload management\r\n-------------------\r\n\r\nCurrently not implemented.\r\n","google":"UA-45195914-1","note":"Don't delete this file! It's used internally to help with page regeneration."}